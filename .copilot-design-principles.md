# AlphaStocks System Design Principles

**Version:** 1.0  
**Last Updated:** October 9, 2025  
**Status:** Active Guidelines

---

## ðŸŽ¯ CRITICAL: Read This First

**This document defines the core architectural principles for AlphaStocks.**  
**ALL code changes MUST follow these principles without exception.**

---

## 1. ðŸš« NO LOCKS POLICY

### Rule: NEVER Use Locks in Event-Driven Components

**Forbidden:**
```python
# âŒ NEVER DO THIS in event-driven code
import threading
self.lock = threading.Lock()

import asyncio
self.lock = asyncio.Lock()

with self.lock:
    # Do something
```

**Why:** Locks create bottlenecks, contention, and deadlock risks. They destroy concurrency.

**Exceptions:**
- âœ… Legacy non-event components (e.g., `candle_aggregator.py`, `historical_data_cache.py`)
- âœ… Local state management within a single component (e.g., `signal_manager_event_driven.py` has ONE lock for `active_signals`)

### Enforcement Checklist:
- [ ] No `threading.Lock()` in event handlers
- [ ] No `asyncio.Lock()` in event processing
- [ ] No `with self.lock:` in event flow
- [ ] Use atomic operations instead (see Section 2)

---

## 2. âœ… USE ATOMIC OPERATIONS

### Rule: Use Thread-Safe Atomic Primitives

**Required Pattern:**
```python
# âœ… ALWAYS DO THIS for statistics/counters
from collections import Counter

self.stats = Counter({
    "signals_received": 0,
    "signals_processed": 0,
    "trades_executed": 0,
})

# Atomic increment (thread-safe)
self.stats["signals_received"] += 1
```

**Why:** `Counter` provides atomic operations without locks. Fast and thread-safe.

### Approved Atomic Tools:
- âœ… `collections.Counter` - For statistics and counting
- âœ… `asyncio.Queue` - For message passing between tasks
- âœ… Immutable dataclasses - For event objects
- âœ… Database queries - For persistent state

### Enforcement Checklist:
- [ ] All statistics use `Counter`
- [ ] No manual dict/list tracking (use DB or Counter)
- [ ] All events are immutable dataclasses
- [ ] Message passing via `asyncio.Queue`

---

## 3. ðŸ”„ INDEPENDENT TASK PER EVENT

### Rule: Each Event Handler Runs in Separate asyncio.Task

**Required Pattern:**
```python
# âœ… ALWAYS DO THIS in EventBus
async def _handle_event(self, event: Event):
    # Create independent task for EACH handler
    tasks = [
        asyncio.create_task(self._execute_handler(subscription, event))
        for subscription in subscriptions
    ]
    
    # Execute ALL handlers in parallel
    results = await asyncio.gather(*tasks, return_exceptions=True)
```

**Why:** Independent tasks = true parallelism, no blocking, failures isolated.

### Characteristics:
- âœ… Each handler spawns own `asyncio.Task`
- âœ… Handlers run in parallel (no waiting)
- âœ… One handler failure doesn't crash others
- âœ… No shared mutable state between handlers
- âœ… Each task is completely independent

### Enforcement Checklist:
- [ ] Event handlers use `asyncio.create_task()`
- [ ] Parallel execution with `asyncio.gather()`
- [ ] Exception handling with `return_exceptions=True`
- [ ] No sequential loops over handlers

---

## 4. ðŸ—„ï¸ DATABASE AS SINGLE SOURCE OF TRUTH

### Rule: NO In-Memory Tracking, Use Database

**Forbidden:**
```python
# âŒ NEVER DO THIS
self.processed_signals = set()  # In-memory tracking
self.active_positions = {}      # In-memory state

if signal_id in self.processed_signals:
    return  # Race condition!
```

**Required:**
```python
# âœ… ALWAYS DO THIS
async def _is_signal_already_processed(self, signal_id: str) -> bool:
    """Check database (single source of truth)"""
    position = self.position_manager.get_position_by_signal(signal_id)
    return position is not None
```

**Why:** Database handles concurrency naturally, provides persistence, and eliminates race conditions.

### Benefits:
- âœ… No race conditions (DB handles locking)
- âœ… Survives restarts (persistent)
- âœ… Single source of truth
- âœ… Query-based idempotency

### Enforcement Checklist:
- [ ] No `self.processed_*` sets/dicts
- [ ] No `self.active_*` in-memory tracking
- [ ] Idempotency via database queries
- [ ] State queries go to database/data layer

---

## 5. ðŸ“¦ EVENT CONTEXT PATTERN

### Rule: Pass ALL Data in Event, No Lookups

**Required:**
```python
# âœ… ALWAYS DO THIS - Complete context in event
await event_bus.publish(
    event_type=EventType.SIGNAL_GENERATED,
    data={
        "signal_id": signal_id,
        "symbol": symbol,
        "action": action,
        "entry_price": entry_price,
        "stop_loss": stop_loss,
        "target": target,
        "signal_strength": signal_strength,
        "expected_move_pct": expected_move_pct,
        "timestamp": timestamp,
        "strategy_name": strategy_name,
        # ... EVERYTHING the handler needs
    },
    source=source
)
```

**Forbidden:**
```python
# âŒ NEVER DO THIS - Incomplete context
await event_bus.publish(
    event_type=EventType.SIGNAL_GENERATED,
    data={"signal_id": signal_id}  # Missing data!
)

# Handler has to lookup shared state
symbol = self.signals[signal_id].symbol  # Race condition!
```

**Why:** No shared state access = no race conditions. Handler is completely independent.

### Enforcement Checklist:
- [ ] All needed data in `event.data`
- [ ] No shared state lookups in handlers
- [ ] Handler can process with only `event.data`
- [ ] No dependencies on other events/state

---

## 6. ðŸ›¡ï¸ HANDLER ISOLATION

### Rule: Handlers Must Be Independent and Isolated

**Requirements:**
```python
async def _execute_handler(self, subscription: Subscription, event: Event) -> bool:
    """Execute handler with isolation"""
    try:
        # Timeout to prevent blocking
        await asyncio.wait_for(subscription.handler(event), timeout=30.0)
        return True
    except asyncio.TimeoutError:
        logger.error(f"Handler timeout: {subscription.subscriber_id}")
        return False
    except Exception as e:
        logger.error(f"Handler error: {e}")
        return False  # Don't let exception escape
```

**Characteristics:**
- âœ… Each handler has timeout (30s default)
- âœ… Exceptions caught and logged
- âœ… Failures don't affect other handlers
- âœ… Dead letter queue for failed events

### Enforcement Checklist:
- [ ] Handler timeouts implemented
- [ ] Exception handling wraps all handlers
- [ ] Failed events go to dead letter queue
- [ ] One failure doesn't crash system

---

## 7. ðŸ“Š MONITORING & OBSERVABILITY

### Rule: Use EventBus Statistics for Monitoring

**Required:**
```python
# âœ… Expose statistics
def get_stats(self) -> Dict[str, Any]:
    return {
        **self._stats,  # Counter stats
        "active_subscriptions": len(self.subscriptions),
        "queue_size": self.event_queue.qsize(),
        "history_size": len(self.event_history),
        "dead_letter_size": len(self.dead_letter_queue),
    }
```

**Why:** Real-time monitoring of system health without performance impact.

### Key Metrics:
- Events published/processed/failed
- Handlers executed/failed
- Queue size (should be ~0)
- Dead letter queue size
- Active subscriptions

### Enforcement Checklist:
- [ ] Statistics exposed via `get_stats()`
- [ ] Atomic counters for all metrics
- [ ] Dead letter queue for failed events
- [ ] Event history (circular buffer)

---

## 8. ðŸ§ª TESTING REQUIREMENTS

### Rule: All Changes Must Pass Concurrent Tests

**Required Test:**
```bash
python tests/test_concurrent_events.py
```

**Minimum Test Coverage:**
- âœ… 100+ concurrent events
- âœ… Multiple handlers per event
- âœ… Race condition detection
- âœ… Handler isolation verification
- âœ… Performance metrics collection

### Success Criteria:
- [ ] 100% event processing (no lost events)
- [ ] Zero race conditions detected
- [ ] Zero deadlocks
- [ ] Handler failures isolated
- [ ] All tests pass

---

## 9. ðŸ“ CODE REVIEW CHECKLIST

### Before Committing ANY Code Change:

#### Architecture:
- [ ] No locks added to event-driven components?
- [ ] Using `collections.Counter` for statistics?
- [ ] Independent `asyncio.Task` per handler?
- [ ] Database queries for state (not in-memory tracking)?
- [ ] All context passed in events?

#### Thread Safety:
- [ ] No shared mutable state?
- [ ] No in-memory sets/dicts for tracking?
- [ ] Atomic operations used?
- [ ] Immutable event objects?

#### Error Handling:
- [ ] Handler timeouts implemented?
- [ ] Exceptions caught and logged?
- [ ] Dead letter queue for failures?
- [ ] Failures don't cascade?

#### Testing:
- [ ] Concurrent test passes?
- [ ] No race conditions detected?
- [ ] Performance acceptable (>10K events/sec)?
- [ ] All imports successful?

#### Documentation:
- [ ] Code comments explain concurrency model?
- [ ] Complex logic documented?
- [ ] Breaking changes noted?

---

## 10. ðŸš¨ ANTI-PATTERNS (NEVER DO THESE)

### âŒ Lock-Based Synchronization
```python
# âŒ FORBIDDEN
with self.lock:
    self.processed_signals.add(signal_id)
```

### âŒ In-Memory State Tracking
```python
# âŒ FORBIDDEN
self.processed_signals = set()
if signal_id in self.processed_signals:
    return
```

### âŒ Sequential Handler Execution
```python
# âŒ FORBIDDEN
for subscription in subscriptions:
    await subscription.handler(event)  # Blocks!
```

### âŒ Shared Mutable State
```python
# âŒ FORBIDDEN
self.shared_dict = {}  # Multiple handlers access this
```

### âŒ Incomplete Event Context
```python
# âŒ FORBIDDEN
data = {"signal_id": id}  # Missing other data!
```

### âŒ Blocking Operations in Handlers
```python
# âŒ FORBIDDEN
def handler(event):
    time.sleep(10)  # Blocks everything!
```

---

## 11. âœ… APPROVED PATTERNS (ALWAYS USE THESE)

### âœ… Atomic Statistics
```python
from collections import Counter
self.stats = Counter()
self.stats["count"] += 1  # Atomic
```

### âœ… Parallel Handler Execution
```python
tasks = [asyncio.create_task(handler(event)) for handler in handlers]
await asyncio.gather(*tasks, return_exceptions=True)
```

### âœ… Database Idempotency
```python
position = db.get_position_by_signal(signal_id)
if position:
    return  # Already processed
```

### âœ… Complete Event Context
```python
data = {
    "signal_id": id,
    "symbol": symbol,
    "all": "needed",
    "data": "here"
}
```

### âœ… Handler Isolation
```python
try:
    await asyncio.wait_for(handler(event), timeout=30.0)
except Exception as e:
    logger.error(f"Handler failed: {e}")
    # Don't let exception escape
```

---

## 12. ðŸ“š REFERENCE DOCUMENTATION

### Primary Documents:
1. **`docs/LOCK_FREE_ARCHITECTURE.md`** - Complete architecture guide
2. **`docs/LOCK_FREE_IMPLEMENTATION_COMPLETE.md`** - Implementation summary
3. **`docs/LOCK_FREE_QUICK_REFERENCE.md`** - Quick reference
4. **`docs/EVENT_DRIVEN_ARCHITECTURE.md`** - Event patterns

### Key Files:
- `src/events/event_bus.py` - Lock-free EventBus implementation
- `src/trading/options_executor_event_driven.py` - Lock-free executor
- `tests/test_concurrent_events.py` - Concurrent test suite

---

## 13. ðŸ”„ VERSION HISTORY

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | Oct 9, 2025 | Initial lock-free architecture guidelines |

---

## 14. ðŸ“ž WHEN IN DOUBT

1. Check if it adds a lock â†’ âŒ DON'T DO IT
2. Check if it uses shared mutable state â†’ âŒ DON'T DO IT
3. Check if handlers run sequentially â†’ âŒ DON'T DO IT
4. Check if it queries database instead â†’ âœ… DO IT
5. Check if it uses atomic Counter â†’ âœ… DO IT
6. Check if handlers are independent â†’ âœ… DO IT

**Golden Rule:** If it needs a lock, redesign it to be lock-free.

---

## 15. ðŸŽ¯ PERFORMANCE TARGETS

| Metric | Target | Current |
|--------|--------|---------|
| Publish Rate | >50,000 events/sec | 60,489 âœ… |
| Process Rate | >100 signals/sec | 150 âœ… |
| Avg Latency | <20ms | 15ms âœ… |
| P99 Latency | <50ms | 26ms âœ… |
| Event Loss Rate | 0% | 0% âœ… |
| Deadlock Rate | 0% | 0% âœ… |

---

**Status:** âœ… Active Guidelines  
**Compliance:** Mandatory for all code changes  
**Review:** Before every commit
